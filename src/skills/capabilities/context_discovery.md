---
id: context_discovery
name: 上下文探索
description: 调查项目上下文，理解现状与依赖关系
type: collection
acceptanceCriteria:
  - when: 选择探索策略
    then: 根据任务类型选择 Macro(宏观) 或 Micro(微观) 策略
  - when: 完成上下文探索
    then: 输出结构化的上下文知识快照
  - when: 信息获取完整
    then: 覆盖关键依赖、数据流、模块职责
---

# 上下文探索

## 核心思维

**调查 (Investigate)** - 通过系统化的信息收集，建立对现有系统的认知模型。

## 典型动作

- 搜代码：使用 Grep/Glob 定位关键入口
- 读文档：扫描 README、设计文档、API 文档
- 理依赖：分析模块间依赖关系、数据流转

## 执行步骤 (SOP)

### 1. 确定探索策略

根据任务类型选择策略：

- **Macro（宏观策略）**：文档优先
  - 适用场景：新项目、架构设计、需求分析
  - 信息源：README、docs/、架构图、CHANGELOG
  - 目标：理解整体设计思路、业务逻辑、模块划分

- **Micro（微观策略）**：代码优先
  - 适用场景：Bug 修复、功能扩展、代码重构
  - 信息源：源代码、类型定义、测试用例
  - 目标：理解具体实现、数据流转、函数调用链

**决策规则**：
- 任务涉及架构设计 → Macro
- 任务涉及具体实现 → Micro
- 任务涉及全新领域 → Macro 先行，再 Micro 深入
- 任务范围明确局部 → Micro 优先

### 2. 入口定位

根据策略执行不同的入口定位方式：

**Macro 入口**：
1. 项目根目录 README.md
2. docs/ 目录下的架构文档
3. package.json / pyproject.toml 等配置文件
4. CHANGELOG.md 了解演进历史

**Micro 入口**：
1. 使用 Grep 搜索关键词定位相关代码
2. 从 src/index.* 或 main.* 入口文件开始
3. 从类型定义文件 (src/types/) 了解数据结构
4. 从测试文件了解使用方式

### 3. 依赖展开

**模块依赖分析**：
- 分析 import/export 关系
- 识别核心模块与辅助模块
- 绘制模块依赖图（心智模型）

**外部依赖分析**：
- 提取生产依赖与开发依赖
- 识别核心依赖库及其用途
- 记录版本约束和兼容性要求

**数据依赖分析**：
- 识别共享的数据结构
- 追踪数据流转路径
- 理解状态管理机制

### 4. 数据流追踪

**对于功能性任务**：
- 从用户输入开始
- 追踪数据经过哪些模块
- 识别数据转换和验证逻辑
- 定位最终输出位置

**对于系统性任务**：
- 识别核心数据结构
- 理解数据持久化方式
- 分析数据同步机制
- 追踪配置传递路径

### 5. 输出知识快照

整理并输出结构化的上下文信息（见输出模板）。

## 检查清单

### Macro 策略检查清单

#### 项目概况
- [ ] **项目简介**：项目是做什么的？
- [ ] **技术栈**：主要使用哪些技术？
- [ ] **运行环境**：Node/Python/Java 版本要求？
- [ ] **项目结构**：主要目录职责是什么？

#### 架构设计
- [ ] **设计文档**：是否有架构设计文档？
- [ ] **模块划分**：核心模块有哪些？
- [ ] **交互关系**：模块间如何交互？
- [ ] **数据流向**：数据如何在系统中流转？

#### 配置与部署
- [ ] **环境变量**：需要哪些环境变量？
- [ ] **配置文件**：配置项有哪些？
- [ ] **启动方式**：如何启动项目？
- [ ] **构建流程**：如何构建部署？

### Micro 策略检查清单

#### 代码入口
- [ ] **入口文件**：主入口文件是哪个？
- [ ] **关键函数**：核心功能函数在哪里？
- [ ] **类型定义**：主要数据结构定义在哪？
- [ ] **接口定义**：对外暴露哪些接口？

#### 依赖关系
- [ ] **模块依赖**：当前模块依赖哪些其他模块？
- [ ] **被依赖关系**：哪些模块依赖当前模块？
- [ ] **外部库**：使用了哪些核心外部库？
- [ ] **版本约束**：依赖版本有什么限制？

#### 数据流转
- [ ] **输入来源**：数据从哪里来？
- [ ] **处理逻辑**：数据如何被处理？
- [ ] **状态管理**：状态如何存储和更新？
- [ ] **输出去向**：数据最终去哪里？

#### 实现细节
- [ ] **核心算法**：关键算法逻辑是什么？
- [ ] **错误处理**：如何处理异常？
- [ ] **边界条件**：有哪些特殊情况处理？
- [ ] **性能考虑**：有哪些性能优化点？

## 信息源优先级

遵循以下优先级获取信息（从高到低）：

1. **Codebase（代码库）**：最可靠的信息源，实现即真相
2. **Docs（文档）**：官方文档、设计文档、API 文档
3. **User（用户）**：向用户确认需求和期望
4. **Public Knowledge（公共知识）**：技术文档、最佳实践、社区方案

**决策规则**：
- 代码与文档冲突时，以代码为准
- 文档缺失时，优先看代码再问用户
- 不确定时，标记为"待确认"并在输出中明确说明

## 输出模板

### Macro 策略输出模板

```markdown
## 探索概要
**探索时间**：[时间]
**探索策略**：Macro（宏观文档优先）
**信息来源**：[主要参考文档列表]

## 项目概况

### 基本信息
- **项目名称**：[名称]
- **项目描述**：[简述]
- **主要技术栈**：[技术列表]
- **运行环境**：[Node/Python/Java 版本要求]

### 项目结构
```
project/
├── src/           # [用途说明]
├── docs/          # [用途说明]
├── tests/         # [用途说明]
└── config/        # [用途说明]
```

## 架构设计

### 模块划分
| 模块名 | 位置 | 职责 | 依赖 |
|--------|------|------|------|
| [模块1] | [路径] | [说明] | [依赖列表] |
| [模块2] | [路径] | [说明] | [依赖列表] |

### 数据流向
[数据如何在系统中流转的描述]

## 依赖信息

### 核心依赖
| 包名 | 版本 | 用途 |
|------|------|------|
| [package1] | [version] | [说明] |
| [package2] | [version] | [说明] |

## 配置说明

### 环境变量
| 变量名 | 默认值 | 说明 | 必需 |
|--------|--------|------|------|
| [VAR_NAME] | [default] | [说明] | ✅/❌ |

### 启动方式
```bash
# 安装依赖
[安装命令]

# 运行项目
[运行命令]
```

## 待确认项
- [ ] [不确定的信息1]
- [ ] [不确定的信息2]

## 参考文档
- [文件路径1] - [说明]
- [文件路径2] - [说明]
```

### Micro 策略输出模板

```markdown
## 探索概要
**探索时间**：[时间]
**探索策略**：Micro（微观代码优先）
**探索范围**：[模块/功能名称]
**入口定位**：[关键文件列表]

## 代码入口

### 主入口
**文件位置**：`src/xxx/index.ts`
**关键函数**：
- `functionA()` - [用途]
- `functionB()` - [用途]

### 类型定义
**位置**：`src/types/xxx.ts`

```typescript
interface KeyInterface {
  field1: Type;
  field2: Type;
}
```

## 模块依赖

### 依赖关系图
```
当前模块
├── 依赖模块A (src/xxx/a.ts)
├── 依赖模块B (src/xxx/b.ts)
└── 外部库C (package-name)
```

### 被依赖情况
- [模块X] 调用本模块的 [函数Y]
- [模块Z] 使用本模块的 [类型定义]

## 数据流转

### 输入
- **来源**：[数据从哪里来]
- **格式**：[数据结构]
- **验证**：[验证逻辑]

### 处理
1. [步骤1描述]
2. [步骤2描述]
3. [步骤3描述]

### 输出
- **去向**：[数据去哪里]
- **格式**：[返回结构]
- **副作用**：[是否有状态变更]

## 核心实现

### 关键算法
**位置**：`src/xxx/core.ts:42-68`
**逻辑**：[算法描述]

### 错误处理
- [错误类型1] → [处理方式]
- [错误类型2] → [处理方式]

### 边界条件
- [特殊情况1] → [处理逻辑]
- [特殊情况2] → [处理逻辑]

## 待确认项
- [ ] [不确定的实现细节1]
- [ ] [不确定的实现细节2]

## 参考代码
- [文件路径:行号] - [说明]
- [文件路径:行号] - [说明]
```

## 探索技巧

### Macro 策略技巧

1. **快速建立全局视图**
   - 先读 README.md 了解项目定位
   - 查看 package.json scripts 了解常用命令
   - 扫描 docs/ 目录获取设计文档

2. **理解演进历史**
   - 查看 CHANGELOG.md 了解重大变更
   - 使用 `git log --oneline --graph` 查看提交历史
   - 关注最近的重要 PR/Issue

3. **识别关键模块**
   - 从目录结构推断模块职责
   - 查看 import 频率识别核心模块
   - 从配置文件推断系统边界

### Micro 策略技巧

1. **快速定位代码**
   - 使用 Grep 搜索函数名/类名
   - 从类型定义文件入手理解接口
   - 查看测试文件了解使用场景

2. **理解调用链**
   - 从入口函数开始追踪
   - 使用 IDE 的 "Find References" 功能
   - 绘制简化的调用时序图

3. **理解数据流**
   - 识别数据结构的定义位置
   - 追踪数据的创建、修改、消费
   - 关注状态管理和副作用

4. **代码阅读顺序**
   - 类型定义 → 接口定义 → 实现逻辑
   - 主流程 → 异常处理 → 边界条件
   - 核心功能 → 辅助工具 → 配置管理

## 验证规则

### 完整性检查

- [ ] **信息覆盖完整**：关键信息点已获取
- [ ] **依赖关系清晰**：模块依赖已梳理
- [ ] **数据流可追踪**：能够描述数据如何流转
- [ ] **待确认项已标注**：不确定信息明确标记

### 准确性检查

- [ ] **信息有明确来源**：每个关键信息都能追溯到代码/文档
- [ ] **版本信息正确**：依赖版本、环境要求准确
- [ ] **路径引用正确**：文件路径、行号准确
- [ ] **代码实例可验证**：引用的代码实际存在

### 可用性检查

- [ ] **结构化清晰**：使用表格、列表、代码块组织信息
- [ ] **关键信息易查**：重要内容突出显示
- [ ] **上下文充足**：提供足够背景信息便于理解
- [ ] **输出格式统一**：遵循输出模板规范

### 策略匹配检查

- [ ] **策略选择合理**：Macro/Micro 选择符合任务特点
- [ ] **信息深度适当**：与任务需求匹配，不过度探索
- [ ] **优先级正确**：按信息源优先级获取信息
- [ ] **置信度标注**：对不确定信息明确标注置信度

## 完成标准

满足以下所有条件即可视为完成：

1. **策略执行完整**：按所选策略完成所有必要步骤
2. **关键信息获取**：任务相关的核心信息已收集
3. **输出结构规范**：按模板输出结构化知识快照
4. **质量验证通过**：通过完整性、准确性、可用性检查
5. **待确认项清晰**：所有不确定信息已明确标注

## 常见问题

### 何时使用 Macro 何时使用 Micro？

- **Macro**：适合全新项目、架构理解、需求分析、技术选型
- **Micro**：适合功能开发、Bug 修复、性能优化、代码重构
- **混合**：复杂任务可先 Macro 建立全局观，再 Micro 深入细节

### 探索深度如何控制？

- 以**任务需求**为界：只探索与任务直接相关的部分
- 遇到**黑盒依赖**：记录接口即可，无需深入内部实现
- 时间限制下：优先核心流程，次要细节标记为"待确认"

### 如何处理不确定信息？

1. 首先尝试从代码库验证
2. 查阅官方文档确认
3. 仍不确定则标记为"待确认"并说明原因
4. 在输出中明确标注置信度（如：推测、未验证）

### 如何平衡探索广度与深度？

- **广度优先**：先建立全局地图，识别关键区域
- **深度聚焦**：在任务相关的关键区域深入探索
- **迭代优化**：可以多次执行，每次聚焦不同方面
